'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = require('./Parser');
var Rule = require('./Rule');
var PostRule = require('./PostRule');
var CalEventFactory = require('./CalEventFactory');

/**
 * handles one rule
 */

var DateFn = function () {
  /**
   * @param {string} rule - unparsed rule
   * @param {array} holidays - all holidays rules (required for bridge day calculations)
   */
  function DateFn(ruleStr, holidays) {
    _classCallCheck(this, DateFn);

    var parser = new Parser();
    this.ruleStr = ruleStr;
    this.rules = parser.parse(ruleStr);
    this.ok = !parser.error;
    this.holidays = holidays;
    this.opts = holidays ? holidays[ruleStr] : {};
    this.event = undefined;
  }

  DateFn.prototype.inYear = function inYear(year) {
    var ruleFn = void 0; // current rule
    var postProc = new PostRule(this.ruleStr, this.opts, this.holidays);

    this.rules.forEach(function (rule) {
      var calEvent = void 0;
      if (rule.fn) {
        calEvent = new CalEventFactory(rule).inYear(year - 1) // run over neighboring dates to catch overlaps
        .inYear(year).inYear(year + 1);
        postProc.push(calEvent);
        ruleFn = new Rule(calEvent);
      } else {
        if (ruleFn.resolve(rule)) {
          postProc.resolve(rule, year);
        }
      }
    });

    this.event = postProc.getEvent(year);
    return this;
  };

  DateFn.prototype.get = function get(timezone) {
    return this.event.get(timezone);
  };

  return DateFn;
}();

module.exports = DateFn;